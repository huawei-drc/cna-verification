// Copyright (c) 2021 Diogo Behrens, Antonio Paolillo
// SPDX-License-Identifier: MIT

/*******************************************************************************
 * Run this client code with GenMC 0.7 to verify the correctness of the
 * CNA slowpath of qspinlock (qspinlock_cna.h) from Linux 5.14.
 * The client code can be alternatively configured to use the MCS slowpath or
 * just the plain MCS lock (mcs_spinlock.h).
 ******************************************************************************/

/* Number of threads */
#ifndef NTHREADS
#define NTHREADS 4
#endif

/* Supported algorithms */
#define QSPINLOCK_CNA 1
#define QSPINLOCK_MCS 2
// Old version of qspicklock containing a liveness bug which is reproducible in hardware.
// This version is to be used with code generated by "make prepared LINUX_VERSION_TYPE=commit-old"
#define QSPINLOCK_MCS_OLD 3 
#ifndef ALGORITHM
#define ALGORITHM     QSPINLOCK_CNA
#endif

// This allows Dartagnan to fully unroll certain loops despite of the bound used for verification.
void __VERIFIER_loop_bound(int);

/*******************************************************************************
 * Includes, context, lock selection -- NO USER OPTIONS FROM HERE ON.
 ******************************************************************************/
#define VERIFICATION

#include <assert.h>
#include <pthread.h>
#include <stddef.h>
#include <stdbool.h>

/* includes distributed in this repository */
#include <linux/atomic.h> /* some linux atomic macros */
#include <defs.h>         /* replacement of several Linux macros */

/* smp_processor_id */
__thread int tid;
#define smp_processor_id() tid

/* functions and macros to retrieve mcs/cna node (context) */
static void *get_node(int cpu);
#define per_cpu_ptr(p, cpu) get_node(cpu)
#define this_cpu_ptr(p) get_node(tid)
#define __this_cpu_dec(x) ((struct mcs_spinlock*) this_cpu_ptr(x))->count--;
#define this_cpu_dec __this_cpu_dec

/* NUMA node mapping and intra-node threshold for CNA */
#if ALGORITHM == QSPINLOCK_CNA
#define CONFIG_NUMA_AWARE_SPINLOCKS
#define cpu_to_node(x) ((x < NTHREADS/2) ? 1 : 2)
static bool cna_threshold_reached = false;
#endif

/* include qspinlock / CNA code */
#define CONFIG_NR_CPUS NTHREADS
#include <asm-generic/qspinlock.h>
#include "kernel/locking/qspinlock.c"

/* select lock and context */
#if ALGORITHM == QSPINLOCK_CNA
	struct qspinlock lock;
	/* use this instead of qnodes to make type clear in debugging */
	struct cna_node nodes[NTHREADS];
	#define init()    cna_init_nodes();
	#define nondet()  WRITE_ONCE(cna_threshold_reached, true);
#elif ALGORITHM == QSPINLOCK_MCS || ALGORITHM == QSPINLOCK_MCS_OLD
	struct qspinlock lock;
#if ALGORITHM == QSPINLOCK_MCS
	#define nodes (*qnodes)
#else
	#define nodes (*mcs_nodes)
#endif
	#define init()
	#define nondet()
#else
	#error "Invalid algorithm"
#endif

static void *get_node(int cpu) { return &nodes[cpu]; }

/*******************************************************************************
 * Client code
 ******************************************************************************/
static int x = 0, y = 0;
static void* run(void *arg)
{
	tid = (intptr_t)arg;

	queued_spin_lock(&lock);
	x = x + 1;
	y = y + 1;
	queued_spin_unlock(&lock);

	return NULL;
}

int main()
{
	pthread_t t0, t1, t2, t3, t4, t5;

	init();

    	pthread_create(&t0, 0, run, (void*)0);
    	pthread_create(&t1, 0, run, (void*)1);
    	pthread_create(&t2, 0, run, (void*)2);
    	pthread_create(&t3, 0, run, (void*)3);

    	nondet();

    	pthread_join(t0, NULL);
    	pthread_join(t1, NULL);
    	pthread_join(t2, NULL);
    	pthread_join(t3, NULL);

    	assert (READ_ONCE(x) == READ_ONCE(y));
	return 0;
}